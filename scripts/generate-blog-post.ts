import 'dotenv/config';
import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = join(__dirname, '..');

// Parse CLI args
const args = process.argv.slice(2);
let gw = 'GW26';
let season = '2025-26';

for (let i = 0; i < args.length; i++) {
  if (args[i] === '--gw' && args[i + 1]) gw = args[++i];
  if (args[i] === '--season' && args[i + 1]) season = args[++i];
}

const gwNumber = parseInt(gw.replace('GW', ''));
const gwDir = join(root, 'data', 'gameweeks', season, gw);
const blogDir = join(root, 'data', 'blog');

if (!existsSync(blogDir)) mkdirSync(blogDir, { recursive: true });

// Load data
const matchesPath = join(gwDir, 'matches.json');
const predictionsPath = join(gwDir, 'predictions.json');

if (!existsSync(matchesPath) || !existsSync(predictionsPath)) {
  console.error(`Missing matches.json or predictions.json in ${gwDir}`);
  process.exit(1);
}

interface Match {
  fixtureId: number;
  league: { id: number; name: string };
  homeTeam: { name: string };
  awayTeam: { name: string };
  kickoff: string;
  odds?: { home: number; draw: number; away: number };
}

interface Prediction {
  fixtureId: number;
  league: string;
  homeTeam: string;
  awayTeam: string;
  homeWinProb: number;
  drawProb: number;
  awayWinProb: number;
  predictedScore: string;
  prediction: string;
  confidence: number;
  explanation?: string;
}

const matches: Match[] = JSON.parse(readFileSync(matchesPath, 'utf-8'));
const predictions: Prediction[] = JSON.parse(readFileSync(predictionsPath, 'utf-8'));

// Group by league
const byLeague = new Map<string, { match: Match; pred: Prediction }[]>();
for (const pred of predictions) {
  const match = matches.find((m) => m.fixtureId === pred.fixtureId);
  if (!match) continue;
  const league = pred.league;
  if (!byLeague.has(league)) byLeague.set(league, []);
  byLeague.get(league)!.push({ match, pred });
}

function leagueSlug(name: string): string {
  return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
}

async function generateBlogContent(
  league: string,
  leagueId: number,
  matchPreds: { match: Match; pred: Prediction }[]
): Promise<string> {
  // Build content without OpenAI — deterministic markdown from data
  const lines: string[] = [];

  lines.push(`This week in the **${league}**, Gameweek ${gwNumber} brings us ${matchPreds.length} fixtures. Here's our AI-powered preview with predicted scores, win probabilities, and confidence ratings.`);
  lines.push('');
  lines.push('---');
  lines.push('');

  for (const { match, pred } of matchPreds) {
    const kickoff = new Date(match.kickoff);
    const dateStr = kickoff.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
    const timeStr = kickoff.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

    const outcome = pred.prediction === 'H' ? pred.homeTeam : pred.prediction === 'A' ? pred.awayTeam : 'Draw';

    lines.push(`## ${pred.homeTeam} vs ${pred.awayTeam}`);
    lines.push('');
    lines.push(`**${dateStr} at ${timeStr}**`);
    lines.push('');
    lines.push(`| | Home | Draw | Away |`);
    lines.push(`|---|---|---|---|`);
    lines.push(`| Probability | ${(pred.homeWinProb * 100).toFixed(1)}% | ${(pred.drawProb * 100).toFixed(1)}% | ${(pred.awayWinProb * 100).toFixed(1)}% |`);

    if (match.odds) {
      lines.push(`| Odds | ${match.odds.home.toFixed(2)} | ${match.odds.draw.toFixed(2)} | ${match.odds.away.toFixed(2)} |`);
    }

    lines.push('');
    lines.push(`**Predicted Score:** ${pred.predictedScore} | **Tip:** ${outcome} | **Confidence:** ${(pred.confidence * 100).toFixed(0)}%`);
    lines.push('');

    if (pred.explanation) {
      lines.push(`> ${pred.explanation}`);
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // ACCA suggestion
  const highConf = matchPreds
    .filter((mp) => mp.pred.confidence >= 0.5)
    .sort((a, b) => b.pred.confidence - a.pred.confidence)
    .slice(0, 3);

  if (highConf.length >= 2) {
    lines.push('## Suggested ACCA');
    lines.push('');
    lines.push('Our highest-confidence picks this gameweek:');
    lines.push('');
    for (const { pred } of highConf) {
      const outcome = pred.prediction === 'H' ? pred.homeTeam : pred.prediction === 'A' ? pred.awayTeam : 'Draw';
      lines.push(`- **${pred.homeTeam} vs ${pred.awayTeam}** — ${outcome} (${(pred.confidence * 100).toFixed(0)}%)`);
    }
    lines.push('');
  }

  lines.push(`*Predictions generated by MyPredictify AI using Elo ratings, Poisson models, and bookmaker odds. Always gamble responsibly.*`);

  return lines.join('\n');
}

async function main() {
  console.log(`Generating blog posts for ${gw} (${season})...`);

  for (const [league, matchPreds] of byLeague) {
    const leagueId = matchPreds[0].match.league.id;
    const slug = `gw${gwNumber}-${leagueSlug(league)}-predictions-${season.split('-')[0]}`;
    const content = await generateBlogContent(league, leagueId, matchPreds);

    const keywords = [
      `${league} predictions`,
      `gameweek ${gwNumber} predictions`,
      `${league} tips`,
      'football predictions',
      'AI predictions',
      ...matchPreds.slice(0, 5).map((mp) => `${mp.pred.homeTeam} vs ${mp.pred.awayTeam}`),
    ];

    const post = {
      slug,
      title: `${league} GW${gwNumber} Predictions — ${season} Season`,
      description: `AI-powered match predictions for ${league} Gameweek ${gwNumber}. Predicted scores, win probabilities, and ACCA suggestions for ${matchPreds.length} fixtures.`,
      league,
      leagueId,
      gameweek: gwNumber,
      season,
      publishedAt: new Date().toISOString(),
      content,
      keywords,
    };

    const outPath = join(blogDir, `${slug}.json`);
    writeFileSync(outPath, JSON.stringify(post, null, 2));
    console.log(`  ✓ ${league}: ${matchPreds.length} matches → ${slug}.json`);
  }

  console.log(`Done! ${byLeague.size} blog posts generated.`);
}

main().catch(console.error);
